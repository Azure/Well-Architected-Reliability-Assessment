<#
.SYNOPSIS
    Represents a recommendation with metadata and query details.

.DESCRIPTION
    Stores information about a recommendation, including its type, description,
    impact, applicable resource type, and evaluation query.
#>
class Recommendation {
    [string] $AprlGuid
    [string] $RecommendationTypeId
    [string] $RecommendationMetadataState
    [string] $RecommendationControl
    [string] $LongDescription
    [string] $Description
    [string] $PotentialBenefits
    [string] $RecommendationResourceType
    [string] $RecommendationImpact
    [string] $Query

    [hashtable] $Links = @{}

    [string[]] $Tags = @()

    [bool] $PgVerified
    [bool] $AutomationAvailable
}

<#
.SYNOPSIS
    Represents a calculated query for a runbook check.

.DESCRIPTION
    This class stores the query details for a specific runbook check,
    including the check name, associated recommendation, and tags.

    Instances of this class are generated by the Build-RunbookQueries function.
#>
class RunbookQuery {
    [string] $CheckSetName
    [string] $CheckName
    [string] $Query

    [string[]] $Tags

    [Recommendation] $Recommendation
}

<#
.SYNOPSIS
    Represents an individual check within a RunbookCheckSet.

.DESCRIPTION
    A RunbookCheck defines a specific validation or evaluation within a
    RunbookCheckSet. It includes a selector for resource filtering,
    configurable parameters, and associated tags.
#>
class RunbookCheck {
    [string] $SelectorName

    [hashtable] $Parameters = @{}

    [string[]] $Tags = @()
}

<#
.SYNOPSIS
    Represents a set of runbook checks.

.DESCRIPTION
    A RunbookCheckSet groups multiple RunbookChecks, allowing them to be
    organized and evaluated together.
#>
class RunbookCheckSet {
    [hashtable] $Checks = @{}
}

<#
.SYNOPSIS
    Represents a runbook for a Well-Architected Reliability Assessment (WARA).

.DESCRIPTION
    The Runbook class defines the structure of a reliability assessment runbook,
    including parameters, variables, selectors, and check sets. It also enforces
    schema validation and ensures correctness through the Validate method.

.NOTES
    - A valid runbook requires at least one selector and one check set.
    - The Validate method checks for missing selectors and query paths.
    - The class includes a JSON schema definition for structured validation.
#>
class Runbook {
    [string[]] $QueryPaths = @()

    [hashtable] $Parameters = @{}
    [hashtable] $Variables = @{}
    [hashtable] $Selectors = @{}
    [hashtable] $CheckSets = @{}

    [void] Validate() {
        $errors = @()

        if ($this.Selectors.Count -eq 0) {
            $errors += "- [selectors]: At least one (1) selector is required."
        }

        if ($this.CheckSets.Count -eq 0) {
            $errors += "- [checks]: At least one (1) check set is required."
        }

        foreach ($queryPath in $this.QueryPaths) {
            if (-not (Test-Path -PathType Container -Path $queryPath)) {
                $errors += "- [query_paths (query_overrides)]: [$queryPath] does not exist or is not a directory."
            }
        }

        foreach ($checkSetKey in $this.CheckSets.Keys) {
            $checkSet = $this.CheckSets[$checkSetKey]

            foreach ($checkKey in $checkSet.Checks.Keys) {
                $check = $checkSet.Checks[$checkKey]
                $checkTitle = "[$checkSetKey]:[$checkKey]"

                if (-not $this.Selectors.ContainsKey($check.SelectorName)) {
                    $errors += "- [checks]: $checkTitle references a selector that does not exist: [$($check.SelectorName)]."
                }
            }
        }

        if ($errors.Count -gt 0) {
            throw "Runbook is invalid:`n$($errors -join "`n")"
        }
    }
}

<#
.SYNOPSIS
    Stores the results of a selector review.

.DESCRIPTION
    The SelectorReview class contains resolved selectors and their associated
    resources after evaluation. It helps users verify that selectors are correctly
    configured and returning the expected results.
#>
class SelectorReview {
    [hashtable] $Selectors = @{}
}

<#
.SYNOPSIS
    Represents a set of resources selected by a query.

.DESCRIPTION
    The SelectedResourceSet class stores the results of a resource selection
    based on a selector and an Azure Resource Graph query.
#>
class SelectedResourceSet {
    [string] $Selector
    [string] $ResourceGraphQuery

    [SelectedResource[]] $Resources = @()
}

<#
.SYNOPSIS
    Represents a selected resource.

.DESCRIPTION
    The SelectedResource class stores details about a resource, including
    its ID, type, name, location, resource group, and tags.
#>
class SelectedResource {
    [string] $ResourceId
    [string] $ResourceType
    [string] $ResourceName
    [string] $ResourceLocation
    [string] $ResourceGroupName

    [hashtable] $ResourceTags = @{}
}

<#
.SYNOPSIS
    Parses and creates Recommendation objects.

.DESCRIPTION
    The RecommendationFactory class provides methods to parse recommendations
    from a JSON file or raw JSON content, returning an array of Recommendation instances.

.NOTES
    - The parsed recommendations include metadata, impact, and related links.
    - If tags or links are missing in the JSON, they are initialized as empty collections.
#>
class RecommendationFactory {
    [Recommendation[]] ParseRecommendationsFile([string] $path) {
        $fileContent = Get-Content -Path $path -Raw
        return $this.ParseRecommendationsContent($fileContent)
    }

    [Recommendation[]] ParseRecommendationsContent([string] $content) {
        $recommendations = @()

        foreach ($contentRecommendation in ($content | ConvertFrom-Json)) {
            $recommendation = [Recommendation]@{
                AprlGuid                    = $contentRecommendation.aprlGuid
                RecommendationTypeId        = $contentRecommendation.recommendationTypeId
                RecommendationMetadataState = $contentRecommendation.recommendationMetadataState
                RecommendationControl       = $contentRecommendation.recommendationControl
                LongDescription             = $contentRecommendation.longDescription
                PgVerified                  = $contentRecommendation.pgVerified
                Description                 = $contentRecommendation.description
                PotentialBenefits           = $contentRecommendation.potentialBenefits
                Tags                        = ($contentRecommendation.tags ?? @())
                RecommendationResourceType  = $contentRecommendation.recommendationResourceType
                RecommendationImpact        = $contentRecommendation.recommendationImpact
                AutomationAvailable         = $contentRecommendation.automationAvailable
                Query                       = $contentRecommendation.query
            }

            foreach ($learnMoreLink in ($contentRecommendation.learnMoreLinks ?? @())) {
                $recommendation.Links[$learnMoreLink.name] = $learnMoreLink.url
            }

            $recommendations += $recommendation
        }

        return $recommendations
    }
}

<#
.SYNOPSIS
    Parses and creates Runbook objects.

.DESCRIPTION
    The RunbookFactory class provides methods to parse runbooks from a JSON file
    or raw JSON content, returning a Runbook instance.

.METHODS
    [Runbook] ParseRunbookFile([string] $path)
        - Reads and parses a runbook from a JSON file.

    [Runbook] ParseRunbookContent([string] $content)
        - Parses a runbook from a JSON-formatted string.

.NOTES
    - If the file does not exist, ParseRunbookFile returns $null.
    - Supports both simple and structured check definitions.
    - Automatically initializes missing properties as empty collections.
#>
class RunbookFactory {
    [Runbook] ParseRunbookFile([string] $path) {
        if (Test-FileExists -Path $path) {
            $fileContent = Get-Content -Path $path -Raw
            return $this.ParseRunbookContent($fileContent)
        }

        return $null
    }

    [Runbook] ParseRunbookContent([string] $content) {
        $runbookHash = ($content | ConvertFrom-Json -AsHashtable)

        $runbook = [Runbook]@{
            QueryPaths = ($runbookHash.query_paths ?? $runbookHash.query_overrides ?? @())
            Parameters = ($runbookHash.parameters ?? @{})
            Variables  = ($runbookHash.variables ?? @{})
            Selectors  = ($runbookHash.selectors ?? @{})
        }

        foreach ($checkSetKey in $runbookHash.checks.Keys) {
            $checkSet = [RunbookCheckSet]::new()
            $checkSetHash = $runbookHash.checks[$checkSetKey]

            foreach ($checkKey in $checkSetHash.Keys) {
                $check = [RunbookCheck]::new()
                $checkValue = $checkSetHash[$checkKey]

                switch ($checkValue.GetType().Name.ToLower()) {
                    "string" {
                        $check.SelectorName = $checkValue
                    }
                    "orderedhashtable" {
                        $check.SelectorName = $checkValue.selector
                        $check.Parameters = ($checkValue.parameters ?? @{})
                        $check.Tags = ($checkValue.tags ?? @())
                    }
                }

                $checkSet.Checks[$checkKey] = $check
            }

            $runbook.CheckSets[$checkSetKey] = $checkSet
        }

        return $runbook
    }
}
